{"version":3,"sources":["TalkForm.js","Comment.js","Talk.js","App.js","serviceWorker.js","index.js"],"names":["TalkForm","createNewTalk","useState","title","setTitle","summary","setSummary","onSubmit","event","preventDefault","target","reset","type","onChange","value","Comment","author","message","className","Talk","talk","deleteTalk","addComment","onClick","presenter","comments","map","comment","index","key","form","elements","name","update","a","tag","undefined","response","fetchOK","headers","Prefer","console","log","Promise","resolve","setTimeout","status","get","json","url","options","fetch","then","Error","statusText","reportError","error","alert","String","talkURL","encodeURIComponent","App","user","setUser","talks","setTalks","useEffect","localStorage","getItem","pollTalks","setItem","method","catch","body","JSON","stringify","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.a5743ed7.chunk.js","sourcesContent":["import React, { useState } from \"react\";\n\nfunction TalkForm({ createNewTalk }) {\n  const [title, setTitle] = useState(\"\");\n  const [summary, setSummary] = useState(\"\");\n  return (\n    <>\n      <form\n        onSubmit={event => {\n          event.preventDefault();\n          createNewTalk({title, summary});\n          event.target.reset();\n        }}\n      >\n        <h3>Submit a Talk</h3>\n        <label>\n          Title:{\" \"}\n          <input type=\"text\" onChange={event => setTitle(event.target.value)} />\n          {\"\\n\"}\n        </label>\n        <label>\n          Summary:{\" \"}\n          <input\n            type=\"text\"\n            onChange={event => setSummary(event.target.value)}\n          />\n        </label>\n        <button type=\"submit\">Submit</button>\n      </form>\n    </>\n  );\n}\n\nexport default TalkForm;\n","import React from \"react\";\n\nfunction Comment({ author, message }) {\n  return (\n    <>\n      <p className=\"comment\">\n        <strong>{author}</strong>: {message}\n      </p>\n    </>\n  );\n}\n\nexport default Comment;","import React from \"react\";\nimport Comment from \"./Comment\";\n\nfunction Talk({ talk, deleteTalk, addComment }) {\n  return (\n    <>\n      <section className=\"talk\">\n        <h2>\n          {talk.title}{\" \"}\n          <button onClick={() => deleteTalk(talk.title)}>Delete</button>\n        </h2>\n        <div>\n          by <strong>{talk.presenter}</strong>\n        </div>\n        <p>{talk.summary}</p>\n        {talk.comments.map((comment, index) => (\n          <Comment {...comment} key={index} />\n        ))}\n        <form\n          onSubmit={event => {\n            event.preventDefault();\n            let form = event.target;\n            addComment(talk.title, form.elements.comment.value);\n            form.reset();\n          }}\n        >\n          <input type=\"text\" name=\"comment\" />{\" \"}\n          <button type=\"submit\">Add comment</button>\n        </form>\n      </section>\n    </>\n  );\n}\n\nexport default Talk;\n","import React, { useEffect, useState } from \"react\";\n// import logo from \"./logo.svg\";\nimport TalkForm from \"./TalkForm\";\nimport Talk from \"./Talk\";\nimport \"./App.css\";\n\nfunction App() {\n  const [user, setUser] = useState(\"\");\n  const [talks, setTalks] = useState([]);\n\n  useEffect(() => {\n    setUser(localStorage.getItem(\"userName\") || \"Anon\");\n    pollTalks(setTalks);\n  }, []);\n\n  useEffect(() => {\n    localStorage.setItem(\"userName\", user);\n  }, [user]);\n\n  const createNewTalk = ({ title, summary }) => {\n    fetchOK(talkURL(title), {\n      method: \"PUT\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        presenter: user,\n        summary: summary\n      })\n    }).catch(reportError);\n  };\n\n  const deleteTalk = title =>\n    fetchOK(talkURL(title), {\n      method: \"DELETE\"\n    }).catch(reportError);\n\n  const addComment = (title, message) =>\n    fetchOK(`${talkURL(title)}/comments`, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        author: user,\n        message: message\n      })\n    }).catch(reportError);\n\n  return (\n    <div className=\"App\">\n      <h1>Skill Sharing (with React)</h1>\n\n      <label>\n        Your name:{\" \"}\n        <input\n          type=\"text\"\n          value={user}\n          onChange={event => setUser(event.target.value)}\n        />\n      </label>\n      {talks.map((talk, index) => (\n        <Talk\n          talk={talk}\n          deleteTalk={deleteTalk}\n          addComment={addComment}\n          key={index}\n        />\n      ))}\n      <TalkForm createNewTalk={createNewTalk} />\n    </div>\n  );\n}\n\nasync function pollTalks(update) {\n  let tag = undefined;\n  for (;;) {\n    let response;\n    try {\n      response = await fetchOK(\"/talks\", {\n        headers: tag && { \"If-None-Match\": tag, Prefer: \"wait=90\" }\n      });\n    } catch (e) {\n      console.log(\"Request failed: \" + e);\n      await new Promise(resolve => setTimeout(resolve, 500));\n      continue;\n    }\n    if (response.status === 304) continue;\n    tag = response.headers.get(\"ETag\");\n    update(await response.json());\n  }\n}\n\nfunction fetchOK(url, options) {\n  return fetch(url, options).then(response => {\n    if (response.status < 400) return response;\n    else throw new Error(response.statusText);\n  });\n}\n\nfunction reportError(error) {\n  alert(String(error));\n}\n\nfunction talkURL(title) {\n  return \"talks/\" + encodeURIComponent(title);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}